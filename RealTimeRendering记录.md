## 第二章：图形渲染管线

### 2.1 整体架构

1. 图形渲染管线和普通流水线一样，都是一个部分流水线主要处理一部分的内容，并且可以并行计算

2. 图形渲染可以说大体分为四个阶段：

   1. 应用阶段（application stage），这个阶段主要做的工作就是包括了真正使用的软件部分，它能够计算各种我们渲染时需要的数据，有一些物理相关的计算，如碰撞检测，全局加速算法那，动画，物理模拟等等都可以在应用阶段进行计算。
   2. 几何处理阶段（Geometry processing），这个阶段主要处理变换，投影，等等各种图形处理，这个阶段要决定什么需要渲染（比如说裁剪），在哪里渲染，要怎么渲染，该阶段开始就是在GPU中计算的了
   3. 光栅化阶段（rasterization stage），光栅化阶段就是将集合处理阶段的顶点数据，转换为我们实际显示需要的像素化的数据，他做的事情就是将找到各个三角形（三角形片元）需要的像素，然后传给下一个阶段
   4. 像素处理阶段（pixel processing stage）,这个阶段就是决定每个像素具体要显示什么颜色，并且可能会计算深度测试判断他是否可见，它还会做一些例如说逐像素的计算，例如说混合颜色等。

   每个阶段都是一个独立的流水线。

3. 一些概念定义

   1. FPS (frame per seconds)
   2. HZ(notation for 1/seconds)

总体而言，这个流水线的结构分成了四个部分，而之前常看见的，顶点着色器=>图元装配（shape assembly）=>几何着色器(geometry)=>=>光栅化（rasterization ）=>测试与混合（test and blending）=>片段着色器（fragment shader）=>光栅化（rasterization ）这个流水线则是上述四个部分的细化，例如前面的顶点着色器开始就是几何处理阶段，和片段着色器就到了最后的像素处理阶段，这也是为什么逐像素光照效果更好的缘故

### 2.2 应用阶段

​	应用阶段做的事情是开发者可以控制的，这种直接运行的程序。开发者在这里的操作会影响整个渲染过程。例如可以在应用层就可以减少需要渲染的三角形的数量。这个阶段可以做的事情有如下几个例子：

1. compute shader，我们可以将一部分计算交给gpu来运算，利用的是gpu强大的并行运算能力。例如说在戴森球计划里面，就大量的运用了这一技术
2. rendering primitives ,应用阶段我们将会将需要渲染的数据填充给几何处理阶段的程序，在性能优化阶段，我们常说的减少drawcall就是这个道理，在应用阶段我们会将需要渲染的点，线，三角形数据传递给下一个阶段。（CPU计算通常是并行的，而渲染管线的计算也通常是并行的，这意味着可能可以通过并行阶段同时feed每一个阶段）
3. 碰撞检测，应用层将会对对象之间的碰撞检测进行计算，这也会影响到某些输入输出
4. 一些优化算法，例如剔除算法（particular culling）

### 2.3 几何处理阶段

几何处理阶段，GPU会处理逐三角形（网格）和逐顶点的操作，这部分的内容主要包括有顶点着色，投影，裁剪，屏幕映射几个放米娜

#### 2.3.1顶点着色

顶点着色主要有两个大的作用一是计算顶点的位置和确定程序需要作为顶点输出的部分，例如输出法线和纹理坐标，传统来说，大部分阴影的计算是通过将光照应用到每个顶点的位置和法向量然后只在顶点数据中存储颜色信息。这部分颜色之后将会在三角形上进行插值计算。因为这个原因，这种可编程的顶点渲染被称为顶点着色器。

顶点着色器通常会计算一些更通用的和顶点相关的数据和信息，例如顶点着色器可以对一个对象进行动画运算。

1. 顶点位置的计算方式，首先我们通常需要一组坐标，在显示到屏幕的过程中，一个模型会被变换到各种不同的坐标系或者空间。
   1. 最初，模型的坐标都是基于他自身的模型空间，每个模型都有一个model transform 这样它才能够定位它自己。由于这个的存在，模型才能在同一个场景下拷贝出相同的结果。
   2. 经过转换，模型会被转换到唯一的世界坐标系中。
   3. 接下来，我们还需要将他转换到照相机的坐标系下，因为只有被摄像机看到的东西，才会被显示。摄像机在世界坐标系中也会有一个坐标来定位。视觉变换矩阵用于设置摄像机位于原点，并且面向Z轴的负方向，这是Y轴向上，而X轴向右，而有的会面向Z轴的正方向，（DX和OPGL），这个坐标系我们称之为view space ,eye space或者camera space
2. 渲染的时候，只渲染形状和位置是不足够的，整体模型的外观也是很重要的。比如光的影响，材质的影响。因此顶点处理还会处理一些额外的内容，比如法向数据，颜色数据，纹理坐标等。最后顶点着色的结果会被送去光栅化阶段进行插值处理，而这个处理总体而言会比像素处理效果差一些
3. 顶点着色的过程还会进行一个投影的处理，投影方式包括了正交/平行投影和透视投影。而投影的方式，这两种方式都可以通过一个4*4矩阵来进行计算。经过投影之后，模型可以说进入了裁剪坐标系中。而顶点着色器的输出结果都得在这个坐标系中，这样裁剪才能正常工作。投影过程中，Z值会被存储到Zbuffer中，这个时候就完成了3D转2D的转换

#### 2.3.2 额外的顶点处理

有些顶点着色处理有几个了额外步骤，平铺。几何着色，输出。当然这个很依赖与GPU，并且不是必须的操作。

1. tessellation: 这个操作的作用是，确定一个object合理的三角形数目，例如，一个足球模型，如果你使用过多三角形来描述它，但是场景中它很远，就是一种浪费计算时间，而这个处理就会选择一个合适的数量的三角形来完成一个更好的表面。顶点着色之后，我们获取到的其实是一系列顶点数据，而在tessellation过程中，它包括了几个步骤，包括了hull shader,tessellator domain shader等等，这些会将顶点坐标处理为新的一组数据，用于生成三角形，这样就能确定具体要显示多少个网格的三角形
2. 几何着色器 geometry shader:几何着色器更为普遍，几何着色器的常见操作例如说模拟一些图像效果例如烟火爆炸，粒子效果等，一个粒子效果，如爆炸，经常被表示为一个点，而几何着色器会将其转换为一个眠，通过两个三角形完成，然后使其面对摄像机，这样子就更方便的处理粒子效果 
3. 流式输出stream output: 这个部分让我们将GPU作为一个简单的几何处理器，在这个阶段那我们可以输出这里的数据用于额外用途，这些数据可以被CPU或者后面的GPU操作使用到，这部分内容也会用于粒子系统

这三个阶段的顺序为tessellation,几何着色，流式输出，而这三个阶段都是任意可选的

#### 2.3.3 裁剪

裁剪阶段，我们会将不需要渲染的部分给裁减掉，从计算来说，我们会将顶点数据和裁剪矩阵进行计算，从物理角度来说，这是使用一个6面的方块进行了裁切，同时，我们还可以定义一个额外的裁切平面进行裁切

在使用过裁剪之后，部分在视野之外的对象会经过额外的处理，会将在外的部分去掉，然后替换为新的顶点数据

#### 2.3.4 屏幕映射

经过裁剪之后，图像还是处于3D坐标系上，而要显示，则还需要映射到屏幕上

X,Y,Z都会被映射为一个新的区间【x1,x2】[y1,y2] 【z1,z2】(-1,1)/(0,1)

接下来我们会将坐标和像素对应，对应方式很简单，像素的中心为0.5(d=floor(c),c=d+0.5)

DX和opengl略有不同

### 2.4 光栅化

光栅化阶段，主要包括了图元装配（三角形setup）和三角形遍历，光栅化的过程主要是确定一个像素是否属于一个三角形

#### 2.4.1 三角形setup

在这个部分，会计算三角形所需要的数据，这些数据会在遍历三角形中所用到，包括了会在像素处理中用到的数据

#### 2.4.2 三角形遍历

在这个阶段，每个被三角形所覆盖的像素都会被检查，并且一个片段（用于片段着色器）将会在这个阶段中生成。每个三角形片段的生成过程会被称为三角形遍历。每个三角形都是通过顶点数据然后通过插值算法生成的。

### 2.5 像素处理

像素处理阶段所处理的像素，是和前面的数据相关联的。这个部分的内容主要分为两个部分，一是像素着色，二是混合

#### 2.5.1 像素着色

像素着色阶段，使用前面阶段计算完成的插值计算后的数据，计算的结果是一个或者多个颜色，然后会传递到下一个阶段，和图元装配和三角形遍历，这部分内容是使用可编程的GPU核心，因此，这部分的内容可以通过片元着色器来定制化。这部分的核心功能是纹理，纹理映射的意思就是将一张图映射到渲染对象上，

#### 2.5.2 混合

每个像素的信息都储存在颜色缓冲中，这是一个颜色矩阵。混合阶段主要负责将像素着色阶段的片段颜色和已经保存在颜色缓冲中的数据混合。这个stage也称作ROP（raster operations pipeline/Raster Operation/ROP-Unit/光栅化处理单元/渲染输出单元）,这个阶段不是完全可编程的，但是高度可配置的。

这个部分还负责处理可见性，即处理什么时候整个场景需要渲染。对于绝大部分图形硬件来说，这是通过Z-BUFFER来处理的，z-buffer和颜色缓冲是有相同大小的。Z值代表着离摄像机的远近，因此，z越大，离摄像机就越近。一个z值较小的像素则不会被渲染。然而这个算法是比较简单的，因此不能用来对半透明对象进行计算，因此半透明对象需要一个特别的算法，并且是需要从后往前进行渲染，需在最后来处理这个。基础z-buffer的弱点就是半透明运算。

α通道和颜色缓冲有关，它保存有每个像素的透明度，（old api）它还被用来做像素的可选性剔除，现在这个剔除操作被插入到片段着色器中，任何一个计算都可以触发一个剔除。α测试能用于保证一个完全透明的片段不影响整个z-buffer

*模版缓冲（*stencil buffer*）或印模缓冲* 是另外一种数据缓冲，和深度缓冲类似，它为屏幕上的每一个像素保存一个8位的无符号整数，从片元着色器出来的数据，在进入到深度测试之前，会进行一个模板测试，我们可以通过这个部分来控制进入到颜色缓冲和z-buffer的数据，从而做到丢弃或者保留某些像素的功能。模板缓冲对于实现某些特效特别有用，。

所有这些功能统称为混合操作，他们就是最终得出三角形的最终颜色的操作。总体而言，该阶段只有有限的可配置的操作，有一些API能够支持可编程的混合能力

帧缓冲（framebuffer）就是由所有上述系统的buffer组合而成的。当所有图形都通过了光栅化阶段，并显示到屏幕上时，他显示的是颜色缓冲中的内容，双缓冲在显示中使用上了。双缓冲的作用就是一个正在显示的前缓冲和一个随时准备替换内容的后缓冲，这部分的替换通常是在vertical retrace中进行替换的

### 2.6 总结整个流水线

==========================

## 3.图形处理单元（Graphics Processing Unit）

（直接翻译）传统上来说，图形加速会在显示三角形需要对每个像素进行插值的时候开始。包括了访问图像数据并将纹理映射到表面上。为插值运算和深度测试添加专门的增加了包含有内置可见性检测功能的硬件。因为频繁的使用，这些流程会交给专门的硬件，这就是GPU。GPU通过专注于一些高并发的任务来提高他们的速度，现在更需要了解的是GPU如何为它的可编程shader进行并发、

​	3.3解释了shader是怎么工作的，现在你需要知道的是，一个shader核心是一个负责做某些相对独立的过任务的处理器。比如说将一个顶点位置转换到一个屏幕坐标系，或者计算一个被三角形覆盖的像素的颜色。在成千上万的三角形被输送到屏幕显示的每一帧的同时，会有大量的shader调用。

​	延时是每个处理器都必须面对的问题，访问数据是需要花费一定的时间的，一个最基本的考虑延迟的方向是考虑当信息和处理器的传输距离越远，处理器需要等待的时间越长，。存储在内存中的信息会比在本地寄存器中的信息花费更长的时间去访问。关键点就在于数据传输的过程会降低性能，因为处理器会空转。

### 3.1 数据平行结构（data parallel architectures）

**CPU**: 为了避免处理器空转？（stalls）有很多种策略都被使用了，CPU被优化来处理更多的数据结构和更大的代码量，CPU可能有多个处理器，不过大部分都使用串行方式运行，受限制的SIMD（单指令多数据）向量处理是一个小小的例外，为了让延时的影响最小，大量的CPU由本地缓存，包含有可能在接下来会使用的数据的内存组成，CPU也会通过非常聪明的例如分支预测（branch prediction）指令重排（instruction reordering)，寄存器重命名（register renaming）和缓存预取（cache prefetching）

**GPU**: GPU使用不同的优化方法。大部分GPU的芯片是专用于某个大型的称为shader cores的大型处理器的。GPU是流式处理器，大量的相似的数据会依次被处理。由于这些数据的相似性，例如一组顶点或者像素，GPU可以使用大规模并行的方式处理这些数据。另一个非常重要的因素是这些调用会尽可能的独立，使得两个相邻的调用之间不会有需要共享的信息，也不会共用一个可写的内存地址。这些规则有时候会被打破，用来支持某些新的并且有用的功能，不过这些例外会带来的代价是潜在的延迟，因为有时候会让一个处理器等待另外一个处理器完成。

通过定义可处理数据的最大速率来对GPU吞吐量（through put）进行了优化。但是这种快速的处理还是有消耗的。当更少的芯片被用于保存内存和控制逻辑，在每个shader core中间的延迟通常都会被认为是高于CPU的

假设一个网格光栅化后有2000个像素包含有片段（fragment）（此处直译）需要处理（片元着色？），一个像素着色器程序将要被调用2000次，而假设这个GPU只有一个shader处理器，这个处理器开始处理这个片段。这个处理器需要对寄存器中的数据做一些算法运算，而寄存器是快速访问的，因此没有任何空转（stalls）,接下来，着色处理器接着处理下一个指令例如纹理映射，而纹理则是一个完全分隔的资源，并不是之前的像素处理中的任何一部分数据，而内存读取会耗费成百上千的时钟周期，而这段时间内GPU将什么都做不了，一直等着纹理数据进行返回。

为了优化这一部分内容，我们可以给每个片段（fragment）的本地寄存器一点空间来保存,因此在进行纹理获取的时候，shader处理器可以进行切换并运行另外一个片段的运算。这个切换是非常快的，而第一个和第二个片段都不会受到影响，然后就是第三个，第四个，最终2000个片段都被处理了，而这时处理器已经成功获取了纹理颜色并且可以使用了，这时候就开始进行下一步运算，和之前一样，这一步也会一直运算直到需要等待或者整个程序运算完成。并行运算将会大大降低一个一个的完整的运算

在这种架构中，延时被GPU切换去其他片段进行运算的行为"藏"起来了，GPU使用这种思想的跟进一步的设计，一个被称为SIMD（single instruction multiple data）单指令多数据的结构，这种结构安排在固定数量的着色程序中，以锁步（lock-step）的方式执行相同的命令。SIMD的优点包括和使用独立的逻辑发送单元相比在处理数据和切换上更加节能省硅？？。如果将我们刚刚的例子中的2000个片段放到现代的GPU当中去，每个片段的像素的着色指令被称为是一个线程，和GPU的线程不同，它包含了一部分输入着色器的值的内存，和着色器运行中需要的着色器空间一起。使用同一个着色器的线程会被组合成一个组，在NVIDIA中被称为一经纱（warp），而AMD中称为波前（wavefront），这些波会被根据GPU的着色核心安排运行的时间，使用SIMD结构运行，每一个线程都会被映射到SIMD lane上

假设有2000个片段需要着色，而我们的NVIDIAGPU包含有32个线程，那么我们产量（yield）就是2000/32 = 62.5warps，这意味着我们需要63warps来完成渲染（是否和纹理最好和2的n此方有关系？），其中一波将会是半空的，一个波的运行很像是我们之前的单个处理器的例子。着色程序锁步的在所有32个处理器上同时运行，当遇到一个内存获取事件时，所有线程都会遇到这个事件，因为所有线程都在执行相同的指令，而这时这一波将会停下来等待数据的获取，然后当前运行的波就会切换到另外一个32个线程的warp去，这个切换将会非常的快，每个线程中的数据不会因为warp的切换而被影响到。每一个线程都有他独立的寄存器，而每个warp都会记录哪一个指令正在被执行，切换到一个新warp只会影响指向不同线程来执行指令的核心。而这不会有间接成本

![shader_process](.\shader_process.png)

着色器程序的结构是非常重要的会影响效率的特性（是否写shader的时候将一些操作放到后面可优化？，更少创建东西来存数据能否优化？），主要的因素是每个线程使用的寄存器数量，当我们有更多的寄存器被着色器程序所需要，那我们就会有更少的线程，因此更少的warp能够存在于GPU中，那么延时就很难被平滑度过，GPU中存在的warp数量被称为occupancy值，这个值越大，意味着有很多warps可以被处理，那么就不会有闲置的处理器，较少的占用率会导致更差的性能，内存访问的频率也会影响有多少延时需要平滑度过。

另外一个影响整体性能的特点是动态分支，被__if__和__while__所影响（shader不要写太多ifwhile），如果在所有的线程中if的结果都是相同的，那处理器可以不用担心另外一个分支，但是如果某一些线程，或者某一个线程走了另外一个分支，那么warp必须要执行所有的分支，获取到一些不需要的结果，。这被称为线程分歧，如果有一少部分线程需要做一个循环或者执行一个if语句，而其他同warp的线程不需要，这会让他们在运行的实践中被闲置

所有的GPU都有实施这些结构的理念，这样使得GPU整体成为了一个被严格限制但是提供了大量的计算力的系统理解这个系统是怎么运行的有助于程序员完成一些更有效率的shader。

### 3.2GPU流水线概览

GPU实现了概念上的图形处理，光栅化，像素处理，这部分流程被分成了几个具有不同程度可配置或可编程的硬件阶段。下图中根据可编程或可配置的方式显示不同阶段的颜色编码 ，注意这些物理阶段和C2中的功能化的阶段有些许不同

![pipeline](.\pipeline.png)

我们在这里描述的是GPU的逻辑模型，这部分会给你暴露API让你使用。这部分逻辑化的流程是由供应商决定的。一个程序可能会被拆分成不同的部分然后被不同的子单元所运行，或者是通过一个完全独立的通道运行，逻辑模型可以让你知道什么会影响性能，但是不应该将它和GPU真正执行的流水线混淆

顶点着色器阶段是一个完全可编程的阶段，这部分用于执行几何处理，。几何着色器也是一个完全可编程的阶段，他会在一个图元（点，线，三角形）的顶点上执行，它能够用于执行pre-primitive shading operation.用于销毁图元或者重新建立模型。镶嵌（tessellation）阶段，和几何着色器阶段都是可选的，，而且不是所有硬件都能支持他们

裁剪，三角形装配，和三角形遍历阶段是被固定功能的硬件所完成的。屏幕映射阶段则是被窗口大小和视口设置所影响，它会在内部实现一个简单的缩放和重定位。像素着色阶段也是完全可编程的（片元着色？）。而尽管合并阶段是不可以编程的，但是它是高度可配置的，而且可以被设置做很多操作，。合并功能阶段主要负责修改颜色，z-buffer，混合，模板操作，以及其他的任何和输出有关的缓冲。像素着色也会和合并阶段一并执行，它们共同组成了第二章所说的像素处理阶段

随着时间的演化，GPU流水线逐渐的从硬编码的方式往提升灵活性和可控制性，这部分介绍的可编程的着色器阶段是这个变化的和新阶段，下一个部分的主要内容则是这些可编程阶段的共性

### 3.3 可编程渲染阶段

现代的着色程序都使用相同的着色器设计，这意味着顶点，片元，几何，镶嵌相关的着色器都使用一个类似的编程风格。在内部，他们有相同的ISA(instruction set architecture)指令集架构。一个有这种模式的处理器被称为普通渲染核心，这种gpu被称为标准着色器架构的GPU。这个架构的背后的想法是着色器实在一定的规则下运行的，而GPU可以按照它认为合适的方式分配他们，例如，一组包含着小三角形的网格会需要比一个大的片但是只被两个三角形组成的更多的顶点着色器处理，GPU有分开的的顶点和片元着色器池可以让意味着理想上可以让每个核心都保持着忙碌的工作。当使用通用的渲染核心的时候，GPU可以平衡这两者。

后面内容会讲到整个着色器编程模型

基础的数据结构是32位的单精度浮点数和向量，尽管向量是渲染代码的一部分，并且并没有在硬件中如刚刚说的所支持。在现代GPU中，32位整数和64位浮点数也是原生被支持的。浮点数向量通常包含有位置(xyzw)，法向，矩阵行，颜色(rgba)或者纹理坐标（uvwq）.整数通常被用来表示计数器，指数，位掩码。集合数据类型例如结构体，数组，还有矩阵也都被支持

一个drawcall 包含了绘制一组图像的API，因此它会让图形渲染管线开始执行，并进行着色。每一个可编程的着色阶段都有两种输入，uniform输入，包含有在整个drawcall中都保持不变的值(在draw call之间可以变)，以及varying输入，来自于三角形顶点的数据或者是光栅化的数据。问题数据是特殊类型的uniform数据，它之前是用于将一个有颜色的图片应用到表面上，但是现在可以看做是一组大量的数据

底层虚拟机提供了一系列独特的寄存器用于不同种类的输入和输出，给uniform用的常量寄存器比其他varying的输入输出的寄存器要多，这是由于varying的输入和输出在每个顶点或像素之间需要独立的存储，所以他会有一个自然地限制他们有多少。而uniform输入存储了一次之后就会在一次drawcall中在所有顶点和像素之间公用。虚拟机同时也含有通用意图的临时寄存器，他们用于提供暂存空间

![Shader_virtual_machine](.\Shader_virtual_machine.png)

在现代GPU中，运行的过程大都相似，着色语言揭露了这些操作的共性。包括了操作符*，+，其他的例如一些函数atan(),sqrt(),log(),还有一些其他的，都被GPU所优化。函数在某些复杂操作中同时也存在，例如向量的的正则化和反射，矩阵平移等

流控制这个术语指的是通过分支指令来对代码的执行进行改变。和流控制相关的指令被用于实现高等编程语言中的一些特性，例如“if",”else“。着色器支持两种类型的流控制，静态的流控制分支基于uniform类型的输入，这意味着这个流的代码在整个drawcall中是常量化的，静态分支的主要好处在于可以允许同一个着色器在各种不同的情况下使用（例如各种光照）。因为调用采用相同的代码路径，所以这里没有线程发散。动态的流式控制依赖于varying的输入，这意味着每个片元可以独立的执行代码。这笔静态的流式控制要更加强大，但是会消耗性能，尤其是在着色器调用之间，选择的代码流不确定的的状态下





### 3.5 顶点着色器

顶点着色器是GPU流水线中的第一个部分，这也是直接开发者控制下的第一个阶段，在这个阶段之前的数据操作是没有意义的。在DX中被称为输入装配（input assembler）中，一部分数据流会组合到一起，形成在流水线中传递的一组三角形和图元。打个比方，一个对象可以被一组顶点数据和一组颜色数据所表示，而这个输入装配中，它会使用带有颜色数据的顶点（vertices）产生这个对象的三角形（或者是点，线）。而另外一个对象也可能会使用同样的位置数据（这个对象会有一个不同的模型变换矩阵）以及不同的颜色数组来表示。在输入装配中，也会用来做实例化，这就允许在每个实例中使用不同的数据多次绘制一个对象，仅仅只需要一次drawcall。

一个三角形网格是被一组顶点表示的，每个顶点都和模型表面上的坐标所关联，出了坐标之外，还有一些额外的属性，例如颜色或者是纹理坐标。表面法向也是在网格中的顶点中所定义的，这个看起来会比较奇怪。数学角度说，每一个三角形都会有一个定义好的表面法向，在着色中直接使用三角形的法向会有一定的意义。但是在渲染中，三角形网格通常被用来表示一个潜在的曲面，而顶点法向则用来表示表面的方向而不是三小型网格本身，下图显示了两个三角形的侧面图，用来表示一个曲面，一个平滑的曲面和一个尖锐的面。

![triangle_meshes](.\triangle_meshes.png)

顶点着色器是第一个处理三角形网格的的。描述三角形形成的数据对顶点着色器是不可用的。就像它的名字说的那样，他只处理输入的顶点。顶点着色器提供了一个用来修改，生成，或是忽略和三角形的顶点相关联的值（如颜色，法向，纹理坐标，位置等）的方法。通常来说，顶点着色器将顶点从模型空间变换到了齐次裁剪空间。一个顶点着色器最少都应该输出这个位置数据。

顶点着色器会处理每一个传进来的顶点，然后接着输出一组在三角形或者是直线上进行插值过后的值。顶点着色器既不能产生顶点，也不能摧毁顶点，而通过一个顶点产生的值并不能传递到另外的顶点上去。因为每一个顶点都是被独立处理的，不管有多少着色处理器，他们都能够对输入的顶点数据流并发的进行处理

 通常情况下，输入装配代表的是顶点着色器执行之前的过程。这里有一个表现物理模型和逻辑模型的差异的例子。物理上来说，获取数据来生成一个顶点可能在顶点着色器中处理，驱动会在背后默默地将每个着色器使用正确的指令进行预设值，而这个操作程序员是不知道的

后面的章节中聊到了顶点着色器影响的其他部分，例如说对动画关节和轮廓渲染进行的顶点混合，其他用法包括

* 对象生成：只创建一个网格一次，并通过顶点着色器对其进行变形
* 角色的身体和面部动画，通过使用skinning and morphing 计数
* 程序上的变形（Procedural deformations），例如旗帜，衣服，水的流动
* 粒子创建，通过传递退化的网格（degenerate meshes）到流水线的以下一段，并且让这些粒子有被给予需要的空间
* 光学变形（lens distortion），热雾（heat haze），水涟漪（water ripples），页面卷曲（page curls）和其他效果，通过使用整个帧缓冲的内容作为一个纹理对一个屏幕对齐网格进行程序变形  
* 应用地形高度场（terrain height fields），通过使用顶点纹理获取

![figure3.8](.\figure3.8.png)

顶点着色器的输出可以通过不同的方式被使用。常规的方式就是每一个实例的图元，例如三角形，被生成然后光栅化，然后将像素传递到片元着色器中。在某些GPU中，这些数据也能被传递到镶嵌阶段或者是几何着色器阶段亦或是在内存中保存。

